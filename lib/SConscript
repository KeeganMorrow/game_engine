# Import the environment configured in SConstruct
Import('env')

import os
import subprocess
import errno
import re
import shutil

def make_sure_path_exists(path):
    try:
        os.makedirs(path)
    except OSError as exception:
        if exception.errno != errno.EEXIST:
            raise

gtestenv = env.Clone()

entityxenv = env.Clone()

gtestenv.Append(CPPPATH=['gtest/include'])
gtestenv.Append(CPPPATH=['gtest/'])

gtestenv.Append(CPPPATH=['gmock/include'])
gtestenv.Append(CPPPATH=['gmock/'])

# Staticlibrary Libraries
gtestenv.StaticLibrary(target ='gmock', source = ['gmock/src/gmock-all.cc', 'gtest/src/gtest-all.cc'], LIBS = 'pthreads')

entityx_dir = '/entityx'

entityx_srcpath = Dir('.').srcnode().abspath + entityx_dir
entityx_buildpath = Dir('.').abspath + entityx_dir

print "entityx_srcpath is %s" % entityx_srcpath

cmakeflags = ''

#TODO: Remember you can pass more info into the environment if necessary
def CMaker(target, source, env):
    """target should be path from repository root to the build directory.
       source should be path from repository root to CMake project directory.
       env should be flags to provide to cmake
    """
    entityx_source_path = env['SRCPATH']
    entityx_build_path = env['BUILDPATH']
    cmake_args = ""

    print "build \"%s\" source \"%s\"" % (entityx_build_path, entityx_source_path)

    make_sure_path_exists(entityx_build_path)

    subprocess.call(['cmake', cmake_args, entityx_source_path], cwd=entityx_build_path)
    subprocess.call(['make'], cwd=entityx_build_path)

    outputfile = './' + env['OUTPUTFILE']
    print "Output file is %s" % (outputfile)
    shutil.copyfile(os.path.join(entityx_buildpath, outputfile), os.path.join(entityx_buildpath,'..', outputfile))

entityx = entityxenv.Command('entityx', 'entityx/CMakeLists.txt', CMaker, OUTPUTFILE="libentityx.a",SRCPATH=entityx_srcpath,BUILDPATH=entityx_buildpath)
AlwaysBuild(entityx)
